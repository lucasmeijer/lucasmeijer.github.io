<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on </title>
    <link>https://lucasmeijer.com/posts/</link>
    <description>Recent content in Posts on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 02 Feb 2019 01:33:37 +0100</lastBuildDate>
    
	<atom:link href="https://lucasmeijer.com/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>There&#39;s no such thing as an API break</title>
      <link>https://lucasmeijer.com/posts/there_is_no_such_thing_as_an_api_break/</link>
      <pubDate>Sat, 02 Feb 2019 01:33:37 +0100</pubDate>
      
      <guid>https://lucasmeijer.com/posts/there_is_no_such_thing_as_an_api_break/</guid>
      <description>Semantic Versioning is pretty popular these days. It basically is a convention that gives some meaning to version numbers. Roughly speaking: if your change breaks API, you should bump the major version, if you just make an improvement or bugfix bump the minor version.
There&amp;rsquo;s nothing wrong with trying trying to convey a convention that lets authors communicate which changes are breaking and which not. What can drive me a bit crazy is when this is mistaken for a rock solid way to know if a change is breaking or not.</description>
    </item>
    
    <item>
      <title>Whats next after Burst</title>
      <link>https://lucasmeijer.com/posts/whats_next_after_burst/</link>
      <pubDate>Fri, 04 Jan 2019 03:34:28 +0100</pubDate>
      
      <guid>https://lucasmeijer.com/posts/whats_next_after_burst/</guid>
      <description>In my previous post I talked about a few fundementals of Unity&amp;rsquo;s Data Oriented Tech Stack (DOTS) future:
 HPC# and Burst compiler Job system  At this point in our tech stack, we can generate some really fast code, we can run jobs safely and efficiently.
I like to refer to this level of our stack as the &amp;ldquo;game engine engine&amp;rdquo;. Anyone can use this stack to write a game engine.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;, C# and Unity</title>
      <link>https://lucasmeijer.com/posts/cpp_unity/</link>
      <pubDate>Thu, 03 Jan 2019 01:33:37 +0100</pubDate>
      
      <guid>https://lucasmeijer.com/posts/cpp_unity/</guid>
      <description>Updated post: fixed mike&amp;rsquo;s twitter handle, replaced example of traffic system with example of path tracer
A lot has been said and written lately about the game industry&amp;rsquo;s &amp;ldquo;C++ is not changing into the thing we need&amp;rdquo; feelings. Valid criticism on various things that make C++ not a great language for games (or at all), and valid counter criticism of &amp;ldquo;well why dont you guys participate in the open-for-everyone process of designing C++ instead of bitching from the sidelines&amp;rdquo;.</description>
    </item>
    
  </channel>
</rss>